function w(r, n) {
  return n instanceof r;
}
function y(r) {
  return typeof r == "string";
}
function b(r) {
  return typeof r == "number" && Number.isFinite(r);
}
function A(r) {
  return typeof r == "boolean";
}
function R(r) {
  return typeof r == "bigint";
}
function M(r) {
  return typeof r == "symbol";
}
function S(r) {
  return typeof r == "undefined";
}
function m(r) {
  return typeof r == "function";
}
function N(r) {
  return r === null;
}
function g(r) {
  return N(r) || S(r);
}
const B = [
  y,
  b,
  A,
  N,
  S,
  R,
  M
];
function D(r) {
  return B.some((n) => n(r));
}
function F(r) {
  return w(Date, r) && b(r.getTime());
}
function x(r) {
  return Array.isArray(r);
}
function j(r) {
  if (D(r))
    return !1;
  const n = Object.getPrototypeOf(r);
  return n === null || n === Object.prototype;
}
function pr(r) {
  if (g(r))
    return !1;
  const n = Object(r);
  return Symbol.iterator in n && m(n[Symbol.iterator]);
}
function lr(r) {
  return typeof r == "object" && r !== null && "then" in r && m(r.then);
}
function T(r) {
  return !g(r);
}
function mr(r) {
  return w(RegExp, r);
}
function dr(r) {
  return w(Set, r);
}
function Er(r) {
  return w(Map, r);
}
function q(r) {
  return r > 0;
}
function Or(r) {
  return !q(r);
}
function L(r) {
  return Number.isInteger(r);
}
function hr(r) {
  return !L(r);
}
function z(r) {
  return r % 2 === 0;
}
function yr(r) {
  return !z(r);
}
function wr(r) {
  if (r < 2)
    return !1;
  const n = Math.sqrt(r);
  for (let t = 2; t <= n; t++)
    if (r % t === 0)
      return !1;
  return !0;
}
function d(r) {
  throw y(r) ? new Error(r) : r;
}
function br(r, n = "Assertion failed") {
  r || d(n);
}
function gr(r) {
  return r;
}
function i(r) {
  return {
    and: () => i(r),
    andThen: () => i(r),
    err: () => l(r),
    expect: (n) => d(n),
    expectErr: () => r,
    inspect: () => i(r),
    inspectErr: (n) => (n(r), i(r)),
    isErr: () => !0,
    isErrAnd: (n) => n(r),
    isOk: () => !1,
    isOkAnd: () => !1,
    map: () => i(r),
    mapErr: (n) => i(n(r)),
    mapOr: (n) => n,
    mapOrElse: (n) => n(r),
    match: (n, t) => t(r),
    ok: () => p,
    or: (n) => n,
    orElse: (n) => n(r),
    unwrap: () => d("called Result.unwrap on an `Err` value"),
    unwrapErr: () => r,
    unwrapOr: (n) => n,
    unwrapOrElse: (n) => n(r)
  };
}
function s(r) {
  return {
    and: (n) => n,
    andThen: (n) => n(r),
    err: () => p,
    expect: () => r,
    expectErr: (n) => d(n),
    inspect: (n) => (n(r), s(r)),
    inspectErr: () => s(r),
    isErr: () => !1,
    isErrAnd: () => !1,
    isOk: () => !0,
    isOkAnd: (n) => n(r),
    map: (n) => s(n(r)),
    mapErr: () => s(r),
    mapOr: (n, t) => t(r),
    mapOrElse: (n, t) => t(r),
    match: (n) => n(r),
    ok: () => l(r),
    or: () => s(r),
    orElse: () => s(r),
    unwrap: () => r,
    unwrapErr: () => d("called Result.unwrapErr on an `Ok` value"),
    unwrapOr: () => r,
    unwrapOrElse: () => r
  };
}
function jr(r) {
  try {
    return s(r());
  } catch (n) {
    return i(n);
  }
}
function C(r) {
  return m(r) ? C(r()) : r.then(s).catch(i);
}
function kr(r) {
  return j(r) && "isOk" in r && m(r.isOk) && "isErr" in r && m(r.isErr);
}
const p = J();
function J() {
  return {
    and: () => p,
    andThen: () => p,
    expect: (r) => d(r),
    filter: () => p,
    inspect: () => p,
    isNone: () => !0,
    isSome: () => !1,
    isSomeAnd: () => !1,
    map: () => p,
    mapOr: (r) => r,
    mapOrElse: (r) => r(),
    match: (r, n) => n(),
    or: (r) => r,
    orElse: (r) => r(),
    unwrap: () => d("called Option.unwrap on a `None` value"),
    unwrapOr: (r) => r,
    unwrapOrElse: (r) => r(),
    okOr: (r) => i(r),
    okOrElse: (r) => i(r())
  };
}
function l(r) {
  return {
    and: (n) => n,
    andThen: (n) => n(r),
    expect: () => r,
    filter: (n) => n(r) ? l(r) : p,
    inspect: (n) => (n(r), l(r)),
    isNone: () => !1,
    isSome: () => !0,
    isSomeAnd: (n) => n(r),
    map: (n) => l(n(r)),
    mapOr: (n, t) => t(r),
    mapOrElse: (n, t) => t(r),
    match: (n) => n(r),
    or: () => l(r),
    orElse: () => l(r),
    unwrap: () => r,
    unwrapOr: () => r,
    unwrapOrElse: () => r,
    okOr: () => s(r),
    okOrElse: () => s(r)
  };
}
function _(r) {
  return T(r) ? l(r) : p;
}
function Sr(r) {
  return j(r) && "isSome" in r && m(r.isSome) && "isNone" in r && m(r.isNone);
}
function E(r, n) {
  return n < 0 ? r.length + n : n;
}
function k(r, n) {
  return _(r[E(r, n)]);
}
function U(r, n, t) {
  t = E(r, t);
  const e = [...r];
  return e.splice(t, 0, n), e;
}
function V(r, n, t) {
  n = E(r, n), t = E(r, t);
  const e = [...r], o = e.splice(n, 1)[0];
  return e.splice(t, 0, o), e;
}
function G(r, n) {
  n = E(r, n);
  const t = [...r];
  return t.splice(n, 1), t;
}
function H(r) {
  const n = [...r];
  for (let t = n.length - 1; t > 0; t--) {
    const e = Math.floor(Math.random() * (t + 1)), o = n[t];
    n[t] = n[e], n[e] = o;
  }
  return n;
}
function K(r, n, t) {
  n = E(r, n), t = E(r, t);
  const e = [...r], o = e[n];
  return e[n] = e[t], e[t] = o, e;
}
function Ar(r, n, t = 1) {
  const e = [];
  let o = r;
  for (; o <= n; )
    e.push(o), o += t;
  return e;
}
function I(r, n) {
  const t = /* @__PURE__ */ Object.create(null);
  for (let e = 0; e < r.length; e++) {
    const o = r[e], u = n(o, e);
    u in t || (t[u] = []), t[u].push(o);
  }
  return t;
}
function Q(r, n) {
  return I(r, (t) => t[n]);
}
function c(r) {
  const n = S(r) ? [] : Array.isArray(r) ? r : Array.from(r);
  return {
    *[Symbol.iterator]() {
      yield* n[Symbol.iterator]();
    },
    append: (...t) => c([...n, ...t]),
    at: (t) => k(n, t),
    concat: (t) => c([...n, ...t]),
    compact: () => c(n.filter(T)),
    drop: (t) => c(n.slice(t)),
    each: (t) => (n.forEach(t), c(n)),
    every: (t) => n.every(t),
    filter: (t) => c(n.filter(t)),
    find: (t) => _(n.find(t)),
    first: () => k(n, 0),
    group: (t) => I(n, t),
    groupBy: (t) => Q(n, t),
    includes: (t) => n.includes(t),
    insert: (t, e) => c(U(n, t, e)),
    isEmpty: () => n.length === 0,
    last: () => k(n, -1),
    len: () => n.length,
    map: (t) => c(n.map(t)),
    move: (t, e) => c(V(n, t, e)),
    prepend: (...t) => c([...t, ...n]),
    reduce: (t, e) => n.reduce(e, t),
    remove: (t) => c(G(n, t)),
    reverse: () => c([...n].reverse()),
    shuffle: () => c(H(n)),
    some: (t) => n.some(t),
    sort: (t) => c([...n].sort(t)),
    swap: (t, e) => c(K(n, t, e)),
    take: (t) => c(n.slice(0, t)),
    toArray: () => [...n],
    toJSON: () => [...n]
  };
}
function f() {
  return {
    path: [],
    message: "",
    actual: "",
    expected: ""
  };
}
const P = (r) => (n) => {
  if (!x(n))
    return i(f());
  const t = new Array(n.length);
  for (let e = 0; e < n.length; e++) {
    const o = r(n[e]);
    if (o.isErr())
      return i(o.unwrapErr());
    t.push(o.unwrap());
  }
  return s(t);
}, W = (r) => (n) => {
  if (r != null && r.coerce)
    if (y(n))
      switch (n.toLowerCase()) {
        case "true":
        case "yes":
        case "on": {
          n = !0;
          break;
        }
        default:
          n = !1;
      }
    else
      n = Boolean(n);
  return A(n) ? s(n) : i(f());
};
function X(r, ...n) {
  return (t) => r(t).andThen(
    (e) => s(n.reduce((o, u) => u(o), e))
  );
}
const Y = (r) => (n) => (r != null && r.coerce && (b(n) || y(n)) && (n = new Date(n)), F(n) ? s(n) : i(f())), Z = (r, n) => (t) => g(t) ? s(n) : r(t), $ = (r) => {
  const n = Object.values(r);
  return (t) => n.includes(t) ? s(t) : i(f());
}, v = (r) => (n) => {
  const t = /* @__PURE__ */ Object.create(null);
  for (const e of r) {
    const o = e(n);
    if (o.isErr())
      return i(o.unwrapErr());
    Object.assign(t, o.unwrap());
  }
  return s(t);
}, rr = (r) => {
  const n = P(r);
  return (t) => n(t).andThen((e) => s(c(e)));
}, nr = (r) => (n) => n === r ? s(n) : i(f());
function tr(r, n) {
  return (t) => r(t).andThen(n);
}
const er = (r) => (n) => (r != null && r.coerce && (n = Number(n)), b(n) ? s(n) : i(f()));
function or(r) {
  const n = Object.entries(r);
  return (t) => {
    if (!j(t))
      return i(f());
    const e = /* @__PURE__ */ Object.create(null);
    for (const [o, u] of n) {
      const a = u(e[o]);
      if (a.isErr())
        return i(a.unwrapErr());
    }
    return s(e);
  };
}
const sr = (r) => (n) => g(n) ? s(p) : r(n).andThen((t) => s(l(t))), ir = (r, n) => (t) => {
  if (!j(t))
    return i(f());
  const e = /* @__PURE__ */ Object.create(null);
  for (const [o, u] of Object.entries(t)) {
    const a = r(o);
    if (a.isErr()) {
      const h = a.unwrapErr();
      return h.path.unshift(o), i(h);
    }
    const O = n(u);
    if (O.isErr()) {
      const h = O.unwrapErr();
      return h.path.unshift(o), i(h);
    }
    e[a.unwrap()] = O.unwrap();
  }
  return s(e);
}, cr = (r) => (n) => (r != null && r.coerce && (n = String(n)), y(n) ? s(r != null && r.trim ? n.trim() : n) : i(f())), ur = (r) => {
  const n = [...r.entries()];
  return (t) => {
    if (!x(t))
      return i(f());
    const e = new Array(r.length);
    for (const [o, u] of n) {
      const a = u(t[o]);
      if (a.isErr()) {
        const O = a.unwrapErr();
        return O.path.unshift(o.toString()), i(O);
      }
      e[o] = a.unwrap();
    }
    return s(e);
  };
}, fr = (r) => (n) => {
  for (const t of r) {
    const e = t(n);
    if (e.isOk())
      return s(e.unwrap());
  }
  return i(f());
}, ar = (r) => s(r), Nr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  array: P,
  boolean: W,
  chain: X,
  date: Y,
  defaulted: Z,
  enums: $,
  intersection: v,
  list: rr,
  literal: nr,
  map: tr,
  number: er,
  object: or,
  optional: sr,
  record: ir,
  string: cr,
  tuple: ur,
  union: fr,
  unknown: ar
}, Symbol.toStringTag, { value: "Module" }));
export {
  i as Err,
  c as List,
  p as None,
  s as Ok,
  l as Some,
  br as assert,
  gr as identity,
  x as isArray,
  R as isBigInt,
  A as isBoolean,
  F as isDate,
  z as isEven,
  hr as isFloat,
  m as isFunction,
  w as isInstanceOf,
  L as isInteger,
  pr as isIterable,
  Er as isMap,
  Or as isNegative,
  g as isNil,
  N as isNull,
  b as isNumber,
  yr as isOdd,
  Sr as isOption,
  j as isPlainObject,
  q as isPositive,
  T as isPresent,
  wr as isPrime,
  D as isPrimitive,
  lr as isPromise,
  mr as isRegExp,
  kr as isResult,
  dr as isSet,
  y as isString,
  M as isSymbol,
  S as isUndefined,
  d as raise,
  Ar as range,
  Nr as t,
  C as toAsyncResult,
  _ as toOption,
  jr as toResult
};
//# sourceMappingURL=typed.js.map
