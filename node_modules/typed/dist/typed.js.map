{"version":3,"file":"typed.js","sources":["../src/type-guards.ts","../src/util.ts","../src/result/err.ts","../src/result/ok.ts","../src/result/util.ts","../src/option/none.ts","../src/option/some.ts","../src/option/util.ts","../src/list/utils.ts","../src/list/list.ts","../src/struct/util.ts","../src/struct/builtin/array.ts","../src/struct/builtin/boolean.ts","../src/struct/builtin/chain.ts","../src/struct/builtin/date.ts","../src/struct/builtin/defaulted.ts","../src/struct/builtin/enums.ts","../src/struct/builtin/intersection.ts","../src/struct/builtin/list.ts","../src/struct/builtin/literal.ts","../src/struct/builtin/map.ts","../src/struct/builtin/number.ts","../src/struct/builtin/object.ts","../src/struct/builtin/optional.ts","../src/struct/builtin/record.ts","../src/struct/builtin/string.ts","../src/struct/builtin/tuple.ts","../src/struct/builtin/union.ts","../src/struct/builtin/unknown.ts"],"sourcesContent":["import type { AnyFunc, Maybe, Nil, PlainObject, Primitive } from \"./types\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isInstanceOf<T extends new (...args: any[]) => any>(\n  constructor: T,\n  value: unknown,\n): value is InstanceType<T> {\n  return value instanceof constructor;\n}\n\nexport function isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === \"number\" && Number.isFinite(value);\n}\n\nexport function isBoolean(value: unknown): value is boolean {\n  return typeof value === \"boolean\";\n}\n\nexport function isBigInt(value: unknown): value is bigint {\n  return typeof value === \"bigint\";\n}\n\nexport function isSymbol(value: unknown): value is symbol {\n  return typeof value === \"symbol\";\n}\n\nexport function isUndefined(value: unknown): value is undefined {\n  return typeof value === \"undefined\";\n}\n\nexport function isFunction(value: unknown): value is AnyFunc {\n  return typeof value === \"function\";\n}\n\nexport function isNull(value: unknown): value is null {\n  return value === null;\n}\n\nexport function isNil(value: unknown): value is Nil {\n  return isNull(value) || isUndefined(value);\n}\n\nconst PRIMITIVES = [\n  isString,\n  isNumber,\n  isBoolean,\n  isNull,\n  isUndefined,\n  isBigInt,\n  isSymbol,\n];\n\nexport function isPrimitive(value: unknown): value is Primitive {\n  return PRIMITIVES.some((f) => f(value));\n}\n\nexport function isDate(value: unknown): value is Date {\n  return isInstanceOf(Date, value) && isNumber(value.getTime());\n}\n\nexport function isArray(value: unknown): value is unknown[] {\n  return Array.isArray(value);\n}\n\nexport function isPlainObject(value: unknown): value is PlainObject {\n  if (isPrimitive(value)) return false;\n  const proto = Object.getPrototypeOf(value);\n  return proto === null || proto === Object.prototype;\n}\n\nexport function isIterable(value: unknown): value is Iterable<unknown> {\n  if (isNil(value)) return false;\n  const obj = Object(value);\n  return Symbol.iterator in obj && isFunction(obj[Symbol.iterator]);\n}\n\nexport function isPromise(value: unknown): value is Promise<unknown> {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"then\" in value &&\n    isFunction(value.then)\n  );\n}\n\nexport function isPresent<T>(value: Maybe<T>): value is T {\n  return !isNil(value);\n}\n\nexport function isRegExp(value: unknown): value is RegExp {\n  return isInstanceOf(RegExp, value);\n}\n\nexport function isSet(value: unknown): value is Set<unknown> {\n  return isInstanceOf(Set, value);\n}\n\nexport function isMap(value: unknown): value is Map<unknown, unknown> {\n  return isInstanceOf(Map, value);\n}\n\nexport function isPositive(num: number): boolean {\n  return num > 0;\n}\n\nexport function isNegative(num: number): boolean {\n  return !isPositive(num);\n}\n\nexport function isInteger(num: number): boolean {\n  return Number.isInteger(num);\n}\n\nexport function isFloat(num: number): boolean {\n  return !isInteger(num);\n}\n\nexport function isEven(num: number): boolean {\n  return num % 2 === 0;\n}\n\nexport function isOdd(num: number): boolean {\n  return !isEven(num);\n}\n\nexport function isPrime(num: number): boolean {\n  if (num < 2) {\n    return false;\n  }\n  const sq = Math.sqrt(num);\n  for (let i = 2; i <= sq; i++) {\n    if (num % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { isString } from \"./type-guards\";\n\nexport function raise(msg: string): never;\nexport function raise(err: Error): never;\nexport function raise(err: string | Error) {\n  if (isString(err)) throw new Error(err);\n  throw err;\n}\n\nexport function assert(\n  condition: unknown,\n  msg = \"Assertion failed\",\n): asserts condition {\n  if (!condition) raise(msg);\n}\n\nexport function identity<T>(arg: T): T {\n  return arg;\n}\n","import { None, Some } from \"../option\";\nimport { raise } from \"../util\";\nimport type { Result } from \"./types\";\n\nexport function Err<E>(value: E): Result<never, E> {\n  return {\n    and: () => Err(value),\n    andThen: () => Err(value),\n    err: () => Some(value),\n    expect: (msg) => raise(msg),\n    expectErr: () => value,\n    inspect: () => Err(value),\n    inspectErr: (f) => {\n      f(value);\n      return Err(value);\n    },\n    isErr: () => true,\n    isErrAnd: (f) => f(value),\n    isOk: () => false,\n    isOkAnd: () => false,\n    map: () => Err(value),\n    mapErr: (op) => Err(op(value)),\n    mapOr: (def) => def,\n    mapOrElse: (def) => def(value),\n    match: (_, err) => err(value),\n    ok: () => None,\n    or: (res) => res,\n    orElse: (op) => op(value),\n    unwrap: () => raise(\"called Result.unwrap on an `Err` value\"),\n    unwrapErr: () => value,\n    unwrapOr: (def) => def,\n    unwrapOrElse: (op) => op(value),\n  };\n}\n","import { None, Some } from \"../option\";\nimport { raise } from \"../util\";\nimport type { Result } from \"./types\";\n\nexport function Ok<T>(value: T): Result<T, never> {\n  return {\n    and: (res) => res,\n    andThen: (op) => op(value),\n    err: () => None,\n    expect: () => value,\n    expectErr: (msg) => raise(msg),\n    inspect: (f) => {\n      f(value);\n      return Ok(value);\n    },\n    inspectErr: () => Ok(value),\n    isErr: () => false,\n    isErrAnd: () => false,\n    isOk: () => true,\n    isOkAnd: (f) => f(value),\n    map: (op) => Ok(op(value)),\n    mapErr: () => Ok(value),\n    mapOr: (_, f) => f(value),\n    mapOrElse: (_, f) => f(value),\n    match: (ok) => ok(value),\n    ok: () => Some(value),\n    or: () => Ok(value),\n    orElse: () => Ok(value),\n    unwrap: () => value,\n    unwrapErr: () => raise(\"called Result.unwrapErr on an `Ok` value\"),\n    unwrapOr: () => value,\n    unwrapOrElse: () => value,\n  };\n}\n","import { isFunction, isPlainObject } from \"../type-guards\";\nimport { Err } from \"./err\";\nimport { Ok } from \"./ok\";\nimport { Result } from \"./types\";\n\nexport function toResult<T>(f: () => T): Result<T, unknown> {\n  try {\n    return Ok(f());\n  } catch (err) {\n    return Err(err);\n  }\n}\n\nexport function toAsyncResult<T>(\n  value: Promise<T> | (() => Promise<T>),\n): Promise<Result<T, unknown>> {\n  if (isFunction(value)) return toAsyncResult(value());\n  return value.then(Ok).catch(Err);\n}\n\nexport function isResult(value: unknown): value is Result<unknown, unknown> {\n  return (\n    isPlainObject(value) &&\n    \"isOk\" in value &&\n    isFunction(value.isOk) &&\n    \"isErr\" in value &&\n    isFunction(value.isErr)\n  );\n}\n","import { Err } from \"../result\";\nimport { raise } from \"../util\";\nimport type { Option } from \"./types\";\n\nexport const NONE = None();\n\nfunction None(): Option<never> {\n  return {\n    and: () => NONE,\n    andThen: () => NONE,\n    expect: (msg) => raise(msg),\n    filter: () => NONE,\n    inspect: () => NONE,\n    isNone: () => true,\n    isSome: () => false,\n    isSomeAnd: () => false,\n    map: () => NONE,\n    mapOr: (def) => def,\n    mapOrElse: (def) => def(),\n    match: (_, f) => f(),\n    or: (optb) => optb,\n    orElse: (f) => f(),\n    unwrap: () => raise(\"called Option.unwrap on a `None` value\"),\n    unwrapOr: (def) => def,\n    unwrapOrElse: (f) => f(),\n    okOr: (v) => Err(v),\n    okOrElse: (f) => Err(f()),\n  };\n}\n","import { Ok } from \"../result\";\nimport { NONE } from \"./none\";\nimport type { Option } from \"./types\";\n\nexport function Some<T>(value: T): Option<T> {\n  return {\n    and: (optb) => optb,\n    andThen: (f) => f(value),\n    expect: () => value,\n    filter: (predicate) => (predicate(value) ? Some(value) : NONE),\n    inspect: (f) => {\n      f(value);\n      return Some(value);\n    },\n    isNone: () => false,\n    isSome: () => true,\n    isSomeAnd: (f) => f(value),\n    map: (f) => Some(f(value)),\n    mapOr: (_, f) => f(value),\n    mapOrElse: (_, f) => f(value),\n    match: (f) => f(value),\n    or: () => Some(value),\n    orElse: () => Some(value),\n    unwrap: () => value,\n    unwrapOr: () => value,\n    unwrapOrElse: () => value,\n    okOr: () => Ok(value),\n    okOrElse: () => Ok(value),\n  };\n}\n","import { isFunction, isPlainObject, isPresent } from \"../type-guards\";\nimport { Maybe } from \"../types\";\nimport { NONE } from \"./none\";\nimport { Some } from \"./some\";\nimport { Option } from \"./types\";\n\nexport function toOption<T>(value: Maybe<T>): Option<T> {\n  return isPresent(value) ? Some(value) : NONE;\n}\n\nexport function isOption(value: unknown): value is Option<unknown> {\n  return (\n    isPlainObject(value) &&\n    \"isSome\" in value &&\n    isFunction(value.isSome) &&\n    \"isNone\" in value &&\n    isFunction(value.isNone)\n  );\n}\n","import { toOption } from \"../option\";\n\nfunction getIndex<T>(arr: readonly T[], at: number): number {\n  return at < 0 ? arr.length + at : at;\n}\n\nexport function at<T>(arr: readonly T[], index: number) {\n  return toOption(arr[getIndex(arr, index)]);\n}\n\nexport function insert<T>(arr: readonly T[], item: T, at: number) {\n  at = getIndex(arr, at);\n  const copy = [...arr];\n  copy.splice(at, 0, item);\n  return copy;\n}\n\nexport function move<T>(arr: readonly T[], from: number, to: number) {\n  from = getIndex(arr, from);\n  to = getIndex(arr, to);\n  const copy = [...arr];\n  const item = copy.splice(from, 1)[0];\n  copy.splice(to, 0, item);\n  return copy;\n}\n\nexport function remove<T>(arr: readonly T[], at: number) {\n  at = getIndex(arr, at);\n  const copy = [...arr];\n  copy.splice(at, 1);\n  return copy;\n}\n\nexport function shuffle<T>(arr: readonly T[]) {\n  const copy = [...arr];\n  for (let i = copy.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = copy[i];\n    copy[i] = copy[j];\n    copy[j] = temp;\n  }\n  return copy;\n}\n\nexport function swap<T>(arr: readonly T[], a: number, b: number) {\n  a = getIndex(arr, a);\n  b = getIndex(arr, b);\n  const copy = [...arr];\n  const temp = copy[a];\n  copy[a] = copy[b];\n  copy[b] = temp;\n  return copy;\n}\n\nexport function range(from: number, to: number, step = 1) {\n  const arr: number[] = [];\n  let i = from;\n  while (i <= to) {\n    arr.push(i);\n    i += step;\n  }\n  return arr;\n}\n\nexport function group<T, K extends PropertyKey>(\n  arr: readonly T[],\n  f: (item: T, index: number) => K,\n) {\n  const obj = Object.create(null);\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    const key = f(item, i);\n    if (!(key in obj)) {\n      obj[key] = [];\n    }\n    obj[key].push(item);\n  }\n  return obj;\n}\n\nexport function groupBy<T, K extends keyof T>(arr: readonly T[], key: K) {\n  return group(arr, (item) => item[key] as PropertyKey);\n}\n","import { Option, toOption } from \"../option\";\nimport { isPresent, isUndefined } from \"../type-guards\";\nimport { Present } from \"../types\";\nimport * as U from \"./utils\";\n\nexport interface List<T> extends Iterable<T> {\n  append(...values: T[]): List<T>;\n  at(index: number): Option<T>;\n  concat(list: List<T>): List<T>;\n  compact(): List<Present<T>>;\n  drop(n: number): List<T>;\n  each(callbackfn: (value: T, index: number) => void): List<T>;\n  every(predicate: (value: T, index: number) => boolean): boolean;\n  filter<U extends T>(\n    callbackfn: (value: T, index: number) => value is U,\n  ): List<U>;\n  find(callbackfn: (value: T, index: number) => boolean): Option<T>;\n  first(): Option<T>;\n  group<K extends PropertyKey>(\n    callbackfn: (value: T, index: number) => K,\n  ): Record<K, T[]>;\n  groupBy<K extends keyof T>(\n    key: K,\n  ): Record<T[K] extends PropertyKey ? T[K] : never, T[]>;\n  includes(item: T): boolean;\n  insert(item: T, at: number): List<T>;\n  isEmpty(): boolean;\n  last(): Option<T>;\n  len(): number;\n  map<U>(callbackfn: (value: T, index: number) => U): List<U>;\n  move(from: number, to: number): List<T>;\n  prepend(...values: T[]): List<T>;\n  reduce<U>(\n    initialValue: U,\n    callbackfn: (previous: U, current: T, index: number) => U,\n  ): U;\n  remove(index: number): List<T>;\n  reverse(): List<T>;\n  shuffle(): List<T>;\n  some(predicate: (value: T, index: number) => boolean): boolean;\n  sort(comparefn?: (a: T, b: T) => number): List<T>;\n  swap(a: number, b: number): List<T>;\n  take(n: number): List<T>;\n  toArray(): T[];\n  toJSON(): T[];\n}\n\nexport type ListInit<T> = Iterable<T> | ArrayLike<T>;\n\nexport function List<T>(init?: ListInit<T>): List<T> {\n  const arr: T[] = isUndefined(init)\n    ? []\n    : Array.isArray(init)\n    ? init\n    : Array.from(init);\n\n  return {\n    *[Symbol.iterator]() {\n      yield* arr[Symbol.iterator]();\n    },\n    append: (...values) => List([...arr, ...values]),\n    at: (index) => U.at(arr, index),\n    concat: (other) => List([...arr, ...other]),\n    compact: () => List(arr.filter(isPresent)) as List<Present<T>>,\n    drop: (n) => List(arr.slice(n)),\n    each: (f) => {\n      arr.forEach(f);\n      return List(arr);\n    },\n    every: (f) => arr.every(f),\n    filter: (f) => List(arr.filter(f)),\n    find: (f) => toOption(arr.find(f)),\n    first: () => U.at(arr, 0),\n    group: (f) => U.group(arr, f),\n    groupBy: (key) => U.groupBy(arr, key),\n    includes: (item) => arr.includes(item),\n    insert: (item, at) => List(U.insert(arr, item, at)),\n    isEmpty: () => arr.length === 0,\n    last: () => U.at(arr, -1),\n    len: () => arr.length,\n    map: (f) => List(arr.map(f)),\n    move: (from, to) => List(U.move(arr, from, to)),\n    prepend: (...values) => List([...values, ...arr]),\n    reduce: (init, f) => arr.reduce(f, init),\n    remove: (index) => List(U.remove(arr, index)),\n    reverse: () => List([...arr].reverse()),\n    shuffle: () => List(U.shuffle(arr)),\n    some: (p) => arr.some(p),\n    sort: (f) => List([...arr].sort(f)),\n    swap: (a, b) => List(U.swap(arr, a, b)),\n    take: (n) => List(arr.slice(0, n)),\n    toArray: () => [...arr],\n    toJSON: () => [...arr],\n  };\n}\n","import { StructError } from \"./types\";\n\nexport function createError(): StructError {\n  return {\n    path: [],\n    message: \"\",\n    actual: \"\",\n    expected: \"\",\n  };\n}\n","import { Err, Ok } from \"../../result\";\nimport { isArray } from \"../../type-guards\";\nimport { Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const array =\n  <T>(struct: Struct<T>): Struct<T[]> =>\n  (input) => {\n    if (!isArray(input)) return Err(createError());\n    const copy: T[] = new Array(input.length);\n    for (let i = 0; i < input.length; i++) {\n      const result = struct(input[i]);\n      if (result.isErr()) {\n        return Err(result.unwrapErr());\n      }\n      copy.push(result.unwrap());\n    }\n    return Ok(copy);\n  };\n","import { Err, Ok } from \"../../result\";\nimport { isBoolean, isString } from \"../../type-guards\";\nimport { Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const boolean =\n  (opts?: { coerce?: boolean }): Struct<boolean> =>\n  (input) => {\n    if (opts?.coerce) {\n      if (isString(input)) {\n        switch (input.toLowerCase()) {\n          case \"true\":\n          case \"yes\":\n          case \"on\": {\n            input = true;\n            break;\n          }\n          default: {\n            input = false;\n          }\n        }\n      } else {\n        input = Boolean(input);\n      }\n    }\n    return isBoolean(input) ? Ok(input) : Err(createError());\n  };\n","import { Ok } from \"../../result\";\nimport { Struct } from \"../types\";\n\nexport function chain<T>(\n  struct: Struct<T>,\n  ...fns: ((value: T) => T)[]\n): Struct<T> {\n  return (input) =>\n    struct(input).andThen((value) =>\n      Ok(fns.reduce((prev, fn) => fn(prev), value)),\n    );\n}\n","import { Err, Ok } from \"../../result\";\nimport { isDate, isNumber, isString } from \"../../type-guards\";\nimport { Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const date = (opts?: { coerce?: boolean }): Struct<Date> => {\n  return (input) => {\n    if (opts?.coerce) {\n      if (isNumber(input) || isString(input)) {\n        input = new Date(input);\n      }\n    }\n    return isDate(input) ? Ok(input) : Err(createError());\n  };\n};\n","import { Ok } from \"../../result\";\nimport { isNil } from \"../../type-guards\";\nimport { Struct } from \"../types\";\n\nexport const defaulted =\n  <T>(struct: Struct<T>, defaultValue: T): Struct<T> =>\n  (input) => {\n    if (isNil(input)) return Ok(defaultValue);\n    return struct(input);\n  };\n","import { Err, Ok } from \"../../result\";\nimport { Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const enums = <T extends { [key: string]: number | string }>(\n  en: T,\n): Struct<T[keyof T]> => {\n  const values = Object.values(en);\n  return (input) =>\n    values.includes(input as string)\n      ? Ok(input as T[keyof T])\n      : Err(createError());\n};\n","import { Err, Ok } from \"../../result\";\nimport { PlainObject } from \"../../types\";\nimport { Infer, InferTuple, Struct, UnionToIntersection } from \"../types\";\n\nexport const intersection =\n  <A extends Struct<PlainObject>, B extends Struct<PlainObject>[]>(\n    structs: [A, ...B],\n  ): Struct<Infer<A> & UnionToIntersection<InferTuple<B>[number]>> =>\n  (input) => {\n    const obj = Object.create(null);\n    for (const struct of structs) {\n      const result = struct(input);\n      if (result.isErr()) return Err(result.unwrapErr());\n      Object.assign(obj, result.unwrap());\n    }\n    return Ok(obj);\n  };\n","import { List } from \"../../list\";\nimport { Ok } from \"../../result\";\nimport { Struct } from \"../types\";\nimport { array } from \"./array\";\n\nexport const list = <T>(struct: Struct<T>): Struct<List<T>> => {\n  const s = array(struct);\n  return (input) => s(input).andThen((value) => Ok(List(value)));\n};\n","import { Err, Ok } from \"../../result\";\nimport { Literal, Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const literal =\n  <T extends Literal>(constant: T): Struct<T> =>\n  (input) =>\n    input === constant ? Ok(input as T) : Err(createError());\n","import { Result } from \"../../result\";\nimport { Struct, StructError } from \"../types\";\n\nexport function map<T, U>(\n  struct: Struct<T>,\n  fn: (value: T) => Result<U, StructError>,\n): Struct<U, StructError> {\n  return (input) => struct(input).andThen(fn);\n}\n","import { Err, Ok } from \"../../result\";\nimport { isNumber } from \"../../type-guards\";\nimport { Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const number =\n  (opts?: { coerce?: boolean }): Struct<number> =>\n  (input) => {\n    if (opts?.coerce) {\n      input = Number(input);\n    }\n    return isNumber(input) ? Ok(input) : Err(createError());\n  };\n","import { Err, Ok } from \"../../result\";\nimport { isPlainObject } from \"../../type-guards\";\nimport { InferShape, Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport function object<T extends { [key: string]: Struct }>(\n  shape: T,\n): Struct<InferShape<T>> {\n  const entries = Object.entries(shape);\n  return (input) => {\n    if (!isPlainObject(input)) return Err(createError());\n    const obj = Object.create(null);\n    for (const [key, struct] of entries) {\n      const result = struct(obj[key]);\n      if (result.isErr()) {\n        return Err(result.unwrapErr());\n      }\n    }\n    return Ok(obj);\n  };\n}\n","import { None, Option, Some } from \"../../option\";\nimport { Ok } from \"../../result\";\nimport { isNil } from \"../../type-guards\";\nimport { Struct } from \"../types\";\n\nexport const optional =\n  <T>(struct: Struct<T>): Struct<Option<T>> =>\n  (input) => {\n    if (isNil(input)) return Ok(None);\n    return struct(input).andThen((value) => Ok(Some(value)));\n  };\n","import { Err, Ok } from \"../../result\";\nimport { isPlainObject } from \"../../type-guards\";\nimport { Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const record =\n  <K extends string, T>(\n    key: Struct<K>,\n    value: Struct<T>,\n  ): Struct<Record<K, T>> =>\n  (input) => {\n    if (!isPlainObject(input)) return Err(createError());\n    const obj = Object.create(null);\n    for (const [k, v] of Object.entries(input)) {\n      const kr = key(k);\n      if (kr.isErr()) {\n        const err = kr.unwrapErr();\n        err.path.unshift(k);\n        return Err(err);\n      }\n      const vr = value(v);\n      if (vr.isErr()) {\n        const err = vr.unwrapErr();\n        err.path.unshift(k);\n        return Err(err);\n      }\n      obj[kr.unwrap()] = vr.unwrap();\n    }\n    return Ok(obj);\n  };\n","import { Err, Ok } from \"../../result\";\nimport { isString } from \"../../type-guards\";\nimport { Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const string =\n  (opts?: { coerce?: boolean; trim?: boolean }): Struct<string> =>\n  (input) => {\n    if (opts?.coerce) {\n      input = String(input);\n    }\n    return isString(input)\n      ? Ok(opts?.trim ? input.trim() : input)\n      : Err(createError());\n  };\n","import { Err, Ok } from \"../../result\";\nimport { isArray } from \"../../type-guards\";\nimport { Infer, InferTuple, Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const tuple = <A extends Struct, B extends Struct[]>(\n  structs: [A, ...B],\n): Struct<[Infer<A>, ...InferTuple<B>]> => {\n  const entries = [...structs.entries()];\n  return (input) => {\n    if (!isArray(input)) return Err(createError());\n    const arr = new Array(structs.length);\n    for (const [i, struct] of entries) {\n      const result = struct(input[i]);\n      if (result.isErr()) {\n        const err = result.unwrapErr();\n        err.path.unshift(i.toString());\n        return Err(err);\n      }\n      arr[i] = result.unwrap();\n    }\n    return Ok(arr as any);\n  };\n};\n","import { Err, Ok } from \"../../result\";\nimport { Infer, InferTuple, Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const union =\n  <A extends Struct, B extends Struct[]>(\n    structs: [A, ...B],\n  ): Struct<Infer<A> | InferTuple<B>[number]> =>\n  (input) => {\n    for (const struct of structs) {\n      const result = struct(input);\n      if (result.isOk()) return Ok(result.unwrap() as any);\n    }\n    return Err(createError());\n  };\n","import { Ok } from \"../../result\";\nimport { Struct } from \"../types\";\n\nexport const unknown: Struct<unknown> = (input) => Ok(input);\n"],"names":["isInstanceOf","constructor","value","isString","isNumber","isBoolean","isBigInt","isSymbol","isUndefined","isFunction","isNull","isNil","PRIMITIVES","isPrimitive","f","isDate","isArray","isPlainObject","proto","isIterable","obj","isPromise","isPresent","isRegExp","isSet","isMap","isPositive","num","isNegative","isInteger","isFloat","isEven","isOdd","isPrime","sq","i","raise","err","assert","condition","msg","identity","arg","Err","Some","op","def","_","None","res","Ok","ok","toResult","toAsyncResult","isResult","NONE","optb","v","predicate","toOption","isOption","getIndex","arr","at","index","insert","item","copy","move","from","to","remove","shuffle","j","temp","swap","a","b","range","step","group","key","groupBy","List","init","values","U.at","other","n","U.group","U.groupBy","U.insert","U.move","U.remove","U.shuffle","p","U.swap","createError","array","struct","input","result","boolean","opts","chain","fns","prev","fn","date","defaulted","defaultValue","enums","en","intersection","structs","list","s","literal","constant","map","number","object","shape","entries","optional","record","k","kr","vr","string","tuple","union","unknown"],"mappings":"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"}