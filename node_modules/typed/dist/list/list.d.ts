import { Option } from "../option";
import { Present } from "../types";
export interface List<T> extends Iterable<T> {
    append(...values: T[]): List<T>;
    at(index: number): Option<T>;
    concat(list: List<T>): List<T>;
    compact(): List<Present<T>>;
    drop(n: number): List<T>;
    each(callbackfn: (value: T, index: number) => void): List<T>;
    every(predicate: (value: T, index: number) => boolean): boolean;
    filter<U extends T>(callbackfn: (value: T, index: number) => value is U): List<U>;
    find(callbackfn: (value: T, index: number) => boolean): Option<T>;
    first(): Option<T>;
    group<K extends PropertyKey>(callbackfn: (value: T, index: number) => K): Record<K, T[]>;
    groupBy<K extends keyof T>(key: K): Record<T[K] extends PropertyKey ? T[K] : never, T[]>;
    includes(item: T): boolean;
    insert(item: T, at: number): List<T>;
    isEmpty(): boolean;
    last(): Option<T>;
    len(): number;
    map<U>(callbackfn: (value: T, index: number) => U): List<U>;
    move(from: number, to: number): List<T>;
    prepend(...values: T[]): List<T>;
    reduce<U>(initialValue: U, callbackfn: (previous: U, current: T, index: number) => U): U;
    remove(index: number): List<T>;
    reverse(): List<T>;
    shuffle(): List<T>;
    some(predicate: (value: T, index: number) => boolean): boolean;
    sort(comparefn?: (a: T, b: T) => number): List<T>;
    swap(a: number, b: number): List<T>;
    take(n: number): List<T>;
    toArray(): T[];
    toJSON(): T[];
}
export type ListInit<T> = Iterable<T> | ArrayLike<T>;
export declare function List<T>(init?: ListInit<T>): List<T>;
