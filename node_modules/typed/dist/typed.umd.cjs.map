{"version":3,"file":"typed.umd.cjs","sources":["../src/type-guards.ts","../src/util.ts","../src/result/err.ts","../src/result/ok.ts","../src/result/util.ts","../src/option/none.ts","../src/option/some.ts","../src/option/util.ts","../src/list/utils.ts","../src/list/list.ts","../src/struct/util.ts","../src/struct/builtin/array.ts","../src/struct/builtin/boolean.ts","../src/struct/builtin/chain.ts","../src/struct/builtin/date.ts","../src/struct/builtin/defaulted.ts","../src/struct/builtin/enums.ts","../src/struct/builtin/intersection.ts","../src/struct/builtin/list.ts","../src/struct/builtin/literal.ts","../src/struct/builtin/map.ts","../src/struct/builtin/number.ts","../src/struct/builtin/object.ts","../src/struct/builtin/optional.ts","../src/struct/builtin/record.ts","../src/struct/builtin/string.ts","../src/struct/builtin/tuple.ts","../src/struct/builtin/union.ts","../src/struct/builtin/unknown.ts"],"sourcesContent":["import type { AnyFunc, Maybe, Nil, PlainObject, Primitive } from \"./types\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isInstanceOf<T extends new (...args: any[]) => any>(\n  constructor: T,\n  value: unknown,\n): value is InstanceType<T> {\n  return value instanceof constructor;\n}\n\nexport function isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === \"number\" && Number.isFinite(value);\n}\n\nexport function isBoolean(value: unknown): value is boolean {\n  return typeof value === \"boolean\";\n}\n\nexport function isBigInt(value: unknown): value is bigint {\n  return typeof value === \"bigint\";\n}\n\nexport function isSymbol(value: unknown): value is symbol {\n  return typeof value === \"symbol\";\n}\n\nexport function isUndefined(value: unknown): value is undefined {\n  return typeof value === \"undefined\";\n}\n\nexport function isFunction(value: unknown): value is AnyFunc {\n  return typeof value === \"function\";\n}\n\nexport function isNull(value: unknown): value is null {\n  return value === null;\n}\n\nexport function isNil(value: unknown): value is Nil {\n  return isNull(value) || isUndefined(value);\n}\n\nconst PRIMITIVES = [\n  isString,\n  isNumber,\n  isBoolean,\n  isNull,\n  isUndefined,\n  isBigInt,\n  isSymbol,\n];\n\nexport function isPrimitive(value: unknown): value is Primitive {\n  return PRIMITIVES.some((f) => f(value));\n}\n\nexport function isDate(value: unknown): value is Date {\n  return isInstanceOf(Date, value) && isNumber(value.getTime());\n}\n\nexport function isArray(value: unknown): value is unknown[] {\n  return Array.isArray(value);\n}\n\nexport function isPlainObject(value: unknown): value is PlainObject {\n  if (isPrimitive(value)) return false;\n  const proto = Object.getPrototypeOf(value);\n  return proto === null || proto === Object.prototype;\n}\n\nexport function isIterable(value: unknown): value is Iterable<unknown> {\n  if (isNil(value)) return false;\n  const obj = Object(value);\n  return Symbol.iterator in obj && isFunction(obj[Symbol.iterator]);\n}\n\nexport function isPromise(value: unknown): value is Promise<unknown> {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"then\" in value &&\n    isFunction(value.then)\n  );\n}\n\nexport function isPresent<T>(value: Maybe<T>): value is T {\n  return !isNil(value);\n}\n\nexport function isRegExp(value: unknown): value is RegExp {\n  return isInstanceOf(RegExp, value);\n}\n\nexport function isSet(value: unknown): value is Set<unknown> {\n  return isInstanceOf(Set, value);\n}\n\nexport function isMap(value: unknown): value is Map<unknown, unknown> {\n  return isInstanceOf(Map, value);\n}\n\nexport function isPositive(num: number): boolean {\n  return num > 0;\n}\n\nexport function isNegative(num: number): boolean {\n  return !isPositive(num);\n}\n\nexport function isInteger(num: number): boolean {\n  return Number.isInteger(num);\n}\n\nexport function isFloat(num: number): boolean {\n  return !isInteger(num);\n}\n\nexport function isEven(num: number): boolean {\n  return num % 2 === 0;\n}\n\nexport function isOdd(num: number): boolean {\n  return !isEven(num);\n}\n\nexport function isPrime(num: number): boolean {\n  if (num < 2) {\n    return false;\n  }\n  const sq = Math.sqrt(num);\n  for (let i = 2; i <= sq; i++) {\n    if (num % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { isString } from \"./type-guards\";\n\nexport function raise(msg: string): never;\nexport function raise(err: Error): never;\nexport function raise(err: string | Error) {\n  if (isString(err)) throw new Error(err);\n  throw err;\n}\n\nexport function assert(\n  condition: unknown,\n  msg = \"Assertion failed\",\n): asserts condition {\n  if (!condition) raise(msg);\n}\n\nexport function identity<T>(arg: T): T {\n  return arg;\n}\n","import { None, Some } from \"../option\";\nimport { raise } from \"../util\";\nimport type { Result } from \"./types\";\n\nexport function Err<E>(value: E): Result<never, E> {\n  return {\n    and: () => Err(value),\n    andThen: () => Err(value),\n    err: () => Some(value),\n    expect: (msg) => raise(msg),\n    expectErr: () => value,\n    inspect: () => Err(value),\n    inspectErr: (f) => {\n      f(value);\n      return Err(value);\n    },\n    isErr: () => true,\n    isErrAnd: (f) => f(value),\n    isOk: () => false,\n    isOkAnd: () => false,\n    map: () => Err(value),\n    mapErr: (op) => Err(op(value)),\n    mapOr: (def) => def,\n    mapOrElse: (def) => def(value),\n    match: (_, err) => err(value),\n    ok: () => None,\n    or: (res) => res,\n    orElse: (op) => op(value),\n    unwrap: () => raise(\"called Result.unwrap on an `Err` value\"),\n    unwrapErr: () => value,\n    unwrapOr: (def) => def,\n    unwrapOrElse: (op) => op(value),\n  };\n}\n","import { None, Some } from \"../option\";\nimport { raise } from \"../util\";\nimport type { Result } from \"./types\";\n\nexport function Ok<T>(value: T): Result<T, never> {\n  return {\n    and: (res) => res,\n    andThen: (op) => op(value),\n    err: () => None,\n    expect: () => value,\n    expectErr: (msg) => raise(msg),\n    inspect: (f) => {\n      f(value);\n      return Ok(value);\n    },\n    inspectErr: () => Ok(value),\n    isErr: () => false,\n    isErrAnd: () => false,\n    isOk: () => true,\n    isOkAnd: (f) => f(value),\n    map: (op) => Ok(op(value)),\n    mapErr: () => Ok(value),\n    mapOr: (_, f) => f(value),\n    mapOrElse: (_, f) => f(value),\n    match: (ok) => ok(value),\n    ok: () => Some(value),\n    or: () => Ok(value),\n    orElse: () => Ok(value),\n    unwrap: () => value,\n    unwrapErr: () => raise(\"called Result.unwrapErr on an `Ok` value\"),\n    unwrapOr: () => value,\n    unwrapOrElse: () => value,\n  };\n}\n","import { isFunction, isPlainObject } from \"../type-guards\";\nimport { Err } from \"./err\";\nimport { Ok } from \"./ok\";\nimport { Result } from \"./types\";\n\nexport function toResult<T>(f: () => T): Result<T, unknown> {\n  try {\n    return Ok(f());\n  } catch (err) {\n    return Err(err);\n  }\n}\n\nexport function toAsyncResult<T>(\n  value: Promise<T> | (() => Promise<T>),\n): Promise<Result<T, unknown>> {\n  if (isFunction(value)) return toAsyncResult(value());\n  return value.then(Ok).catch(Err);\n}\n\nexport function isResult(value: unknown): value is Result<unknown, unknown> {\n  return (\n    isPlainObject(value) &&\n    \"isOk\" in value &&\n    isFunction(value.isOk) &&\n    \"isErr\" in value &&\n    isFunction(value.isErr)\n  );\n}\n","import { Err } from \"../result\";\nimport { raise } from \"../util\";\nimport type { Option } from \"./types\";\n\nexport const NONE = None();\n\nfunction None(): Option<never> {\n  return {\n    and: () => NONE,\n    andThen: () => NONE,\n    expect: (msg) => raise(msg),\n    filter: () => NONE,\n    inspect: () => NONE,\n    isNone: () => true,\n    isSome: () => false,\n    isSomeAnd: () => false,\n    map: () => NONE,\n    mapOr: (def) => def,\n    mapOrElse: (def) => def(),\n    match: (_, f) => f(),\n    or: (optb) => optb,\n    orElse: (f) => f(),\n    unwrap: () => raise(\"called Option.unwrap on a `None` value\"),\n    unwrapOr: (def) => def,\n    unwrapOrElse: (f) => f(),\n    okOr: (v) => Err(v),\n    okOrElse: (f) => Err(f()),\n  };\n}\n","import { Ok } from \"../result\";\nimport { NONE } from \"./none\";\nimport type { Option } from \"./types\";\n\nexport function Some<T>(value: T): Option<T> {\n  return {\n    and: (optb) => optb,\n    andThen: (f) => f(value),\n    expect: () => value,\n    filter: (predicate) => (predicate(value) ? Some(value) : NONE),\n    inspect: (f) => {\n      f(value);\n      return Some(value);\n    },\n    isNone: () => false,\n    isSome: () => true,\n    isSomeAnd: (f) => f(value),\n    map: (f) => Some(f(value)),\n    mapOr: (_, f) => f(value),\n    mapOrElse: (_, f) => f(value),\n    match: (f) => f(value),\n    or: () => Some(value),\n    orElse: () => Some(value),\n    unwrap: () => value,\n    unwrapOr: () => value,\n    unwrapOrElse: () => value,\n    okOr: () => Ok(value),\n    okOrElse: () => Ok(value),\n  };\n}\n","import { isFunction, isPlainObject, isPresent } from \"../type-guards\";\nimport { Maybe } from \"../types\";\nimport { NONE } from \"./none\";\nimport { Some } from \"./some\";\nimport { Option } from \"./types\";\n\nexport function toOption<T>(value: Maybe<T>): Option<T> {\n  return isPresent(value) ? Some(value) : NONE;\n}\n\nexport function isOption(value: unknown): value is Option<unknown> {\n  return (\n    isPlainObject(value) &&\n    \"isSome\" in value &&\n    isFunction(value.isSome) &&\n    \"isNone\" in value &&\n    isFunction(value.isNone)\n  );\n}\n","import { toOption } from \"../option\";\n\nfunction getIndex<T>(arr: readonly T[], at: number): number {\n  return at < 0 ? arr.length + at : at;\n}\n\nexport function at<T>(arr: readonly T[], index: number) {\n  return toOption(arr[getIndex(arr, index)]);\n}\n\nexport function insert<T>(arr: readonly T[], item: T, at: number) {\n  at = getIndex(arr, at);\n  const copy = [...arr];\n  copy.splice(at, 0, item);\n  return copy;\n}\n\nexport function move<T>(arr: readonly T[], from: number, to: number) {\n  from = getIndex(arr, from);\n  to = getIndex(arr, to);\n  const copy = [...arr];\n  const item = copy.splice(from, 1)[0];\n  copy.splice(to, 0, item);\n  return copy;\n}\n\nexport function remove<T>(arr: readonly T[], at: number) {\n  at = getIndex(arr, at);\n  const copy = [...arr];\n  copy.splice(at, 1);\n  return copy;\n}\n\nexport function shuffle<T>(arr: readonly T[]) {\n  const copy = [...arr];\n  for (let i = copy.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = copy[i];\n    copy[i] = copy[j];\n    copy[j] = temp;\n  }\n  return copy;\n}\n\nexport function swap<T>(arr: readonly T[], a: number, b: number) {\n  a = getIndex(arr, a);\n  b = getIndex(arr, b);\n  const copy = [...arr];\n  const temp = copy[a];\n  copy[a] = copy[b];\n  copy[b] = temp;\n  return copy;\n}\n\nexport function range(from: number, to: number, step = 1) {\n  const arr: number[] = [];\n  let i = from;\n  while (i <= to) {\n    arr.push(i);\n    i += step;\n  }\n  return arr;\n}\n\nexport function group<T, K extends PropertyKey>(\n  arr: readonly T[],\n  f: (item: T, index: number) => K,\n) {\n  const obj = Object.create(null);\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    const key = f(item, i);\n    if (!(key in obj)) {\n      obj[key] = [];\n    }\n    obj[key].push(item);\n  }\n  return obj;\n}\n\nexport function groupBy<T, K extends keyof T>(arr: readonly T[], key: K) {\n  return group(arr, (item) => item[key] as PropertyKey);\n}\n","import { Option, toOption } from \"../option\";\nimport { isPresent, isUndefined } from \"../type-guards\";\nimport { Present } from \"../types\";\nimport * as U from \"./utils\";\n\nexport interface List<T> extends Iterable<T> {\n  append(...values: T[]): List<T>;\n  at(index: number): Option<T>;\n  concat(list: List<T>): List<T>;\n  compact(): List<Present<T>>;\n  drop(n: number): List<T>;\n  each(callbackfn: (value: T, index: number) => void): List<T>;\n  every(predicate: (value: T, index: number) => boolean): boolean;\n  filter<U extends T>(\n    callbackfn: (value: T, index: number) => value is U,\n  ): List<U>;\n  find(callbackfn: (value: T, index: number) => boolean): Option<T>;\n  first(): Option<T>;\n  group<K extends PropertyKey>(\n    callbackfn: (value: T, index: number) => K,\n  ): Record<K, T[]>;\n  groupBy<K extends keyof T>(\n    key: K,\n  ): Record<T[K] extends PropertyKey ? T[K] : never, T[]>;\n  includes(item: T): boolean;\n  insert(item: T, at: number): List<T>;\n  isEmpty(): boolean;\n  last(): Option<T>;\n  len(): number;\n  map<U>(callbackfn: (value: T, index: number) => U): List<U>;\n  move(from: number, to: number): List<T>;\n  prepend(...values: T[]): List<T>;\n  reduce<U>(\n    initialValue: U,\n    callbackfn: (previous: U, current: T, index: number) => U,\n  ): U;\n  remove(index: number): List<T>;\n  reverse(): List<T>;\n  shuffle(): List<T>;\n  some(predicate: (value: T, index: number) => boolean): boolean;\n  sort(comparefn?: (a: T, b: T) => number): List<T>;\n  swap(a: number, b: number): List<T>;\n  take(n: number): List<T>;\n  toArray(): T[];\n  toJSON(): T[];\n}\n\nexport type ListInit<T> = Iterable<T> | ArrayLike<T>;\n\nexport function List<T>(init?: ListInit<T>): List<T> {\n  const arr: T[] = isUndefined(init)\n    ? []\n    : Array.isArray(init)\n    ? init\n    : Array.from(init);\n\n  return {\n    *[Symbol.iterator]() {\n      yield* arr[Symbol.iterator]();\n    },\n    append: (...values) => List([...arr, ...values]),\n    at: (index) => U.at(arr, index),\n    concat: (other) => List([...arr, ...other]),\n    compact: () => List(arr.filter(isPresent)) as List<Present<T>>,\n    drop: (n) => List(arr.slice(n)),\n    each: (f) => {\n      arr.forEach(f);\n      return List(arr);\n    },\n    every: (f) => arr.every(f),\n    filter: (f) => List(arr.filter(f)),\n    find: (f) => toOption(arr.find(f)),\n    first: () => U.at(arr, 0),\n    group: (f) => U.group(arr, f),\n    groupBy: (key) => U.groupBy(arr, key),\n    includes: (item) => arr.includes(item),\n    insert: (item, at) => List(U.insert(arr, item, at)),\n    isEmpty: () => arr.length === 0,\n    last: () => U.at(arr, -1),\n    len: () => arr.length,\n    map: (f) => List(arr.map(f)),\n    move: (from, to) => List(U.move(arr, from, to)),\n    prepend: (...values) => List([...values, ...arr]),\n    reduce: (init, f) => arr.reduce(f, init),\n    remove: (index) => List(U.remove(arr, index)),\n    reverse: () => List([...arr].reverse()),\n    shuffle: () => List(U.shuffle(arr)),\n    some: (p) => arr.some(p),\n    sort: (f) => List([...arr].sort(f)),\n    swap: (a, b) => List(U.swap(arr, a, b)),\n    take: (n) => List(arr.slice(0, n)),\n    toArray: () => [...arr],\n    toJSON: () => [...arr],\n  };\n}\n","import { StructError } from \"./types\";\n\nexport function createError(): StructError {\n  return {\n    path: [],\n    message: \"\",\n    actual: \"\",\n    expected: \"\",\n  };\n}\n","import { Err, Ok } from \"../../result\";\nimport { isArray } from \"../../type-guards\";\nimport { Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const array =\n  <T>(struct: Struct<T>): Struct<T[]> =>\n  (input) => {\n    if (!isArray(input)) return Err(createError());\n    const copy: T[] = new Array(input.length);\n    for (let i = 0; i < input.length; i++) {\n      const result = struct(input[i]);\n      if (result.isErr()) {\n        return Err(result.unwrapErr());\n      }\n      copy.push(result.unwrap());\n    }\n    return Ok(copy);\n  };\n","import { Err, Ok } from \"../../result\";\nimport { isBoolean, isString } from \"../../type-guards\";\nimport { Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const boolean =\n  (opts?: { coerce?: boolean }): Struct<boolean> =>\n  (input) => {\n    if (opts?.coerce) {\n      if (isString(input)) {\n        switch (input.toLowerCase()) {\n          case \"true\":\n          case \"yes\":\n          case \"on\": {\n            input = true;\n            break;\n          }\n          default: {\n            input = false;\n          }\n        }\n      } else {\n        input = Boolean(input);\n      }\n    }\n    return isBoolean(input) ? Ok(input) : Err(createError());\n  };\n","import { Ok } from \"../../result\";\nimport { Struct } from \"../types\";\n\nexport function chain<T>(\n  struct: Struct<T>,\n  ...fns: ((value: T) => T)[]\n): Struct<T> {\n  return (input) =>\n    struct(input).andThen((value) =>\n      Ok(fns.reduce((prev, fn) => fn(prev), value)),\n    );\n}\n","import { Err, Ok } from \"../../result\";\nimport { isDate, isNumber, isString } from \"../../type-guards\";\nimport { Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const date = (opts?: { coerce?: boolean }): Struct<Date> => {\n  return (input) => {\n    if (opts?.coerce) {\n      if (isNumber(input) || isString(input)) {\n        input = new Date(input);\n      }\n    }\n    return isDate(input) ? Ok(input) : Err(createError());\n  };\n};\n","import { Ok } from \"../../result\";\nimport { isNil } from \"../../type-guards\";\nimport { Struct } from \"../types\";\n\nexport const defaulted =\n  <T>(struct: Struct<T>, defaultValue: T): Struct<T> =>\n  (input) => {\n    if (isNil(input)) return Ok(defaultValue);\n    return struct(input);\n  };\n","import { Err, Ok } from \"../../result\";\nimport { Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const enums = <T extends { [key: string]: number | string }>(\n  en: T,\n): Struct<T[keyof T]> => {\n  const values = Object.values(en);\n  return (input) =>\n    values.includes(input as string)\n      ? Ok(input as T[keyof T])\n      : Err(createError());\n};\n","import { Err, Ok } from \"../../result\";\nimport { PlainObject } from \"../../types\";\nimport { Infer, InferTuple, Struct, UnionToIntersection } from \"../types\";\n\nexport const intersection =\n  <A extends Struct<PlainObject>, B extends Struct<PlainObject>[]>(\n    structs: [A, ...B],\n  ): Struct<Infer<A> & UnionToIntersection<InferTuple<B>[number]>> =>\n  (input) => {\n    const obj = Object.create(null);\n    for (const struct of structs) {\n      const result = struct(input);\n      if (result.isErr()) return Err(result.unwrapErr());\n      Object.assign(obj, result.unwrap());\n    }\n    return Ok(obj);\n  };\n","import { List } from \"../../list\";\nimport { Ok } from \"../../result\";\nimport { Struct } from \"../types\";\nimport { array } from \"./array\";\n\nexport const list = <T>(struct: Struct<T>): Struct<List<T>> => {\n  const s = array(struct);\n  return (input) => s(input).andThen((value) => Ok(List(value)));\n};\n","import { Err, Ok } from \"../../result\";\nimport { Literal, Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const literal =\n  <T extends Literal>(constant: T): Struct<T> =>\n  (input) =>\n    input === constant ? Ok(input as T) : Err(createError());\n","import { Result } from \"../../result\";\nimport { Struct, StructError } from \"../types\";\n\nexport function map<T, U>(\n  struct: Struct<T>,\n  fn: (value: T) => Result<U, StructError>,\n): Struct<U, StructError> {\n  return (input) => struct(input).andThen(fn);\n}\n","import { Err, Ok } from \"../../result\";\nimport { isNumber } from \"../../type-guards\";\nimport { Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const number =\n  (opts?: { coerce?: boolean }): Struct<number> =>\n  (input) => {\n    if (opts?.coerce) {\n      input = Number(input);\n    }\n    return isNumber(input) ? Ok(input) : Err(createError());\n  };\n","import { Err, Ok } from \"../../result\";\nimport { isPlainObject } from \"../../type-guards\";\nimport { InferShape, Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport function object<T extends { [key: string]: Struct }>(\n  shape: T,\n): Struct<InferShape<T>> {\n  const entries = Object.entries(shape);\n  return (input) => {\n    if (!isPlainObject(input)) return Err(createError());\n    const obj = Object.create(null);\n    for (const [key, struct] of entries) {\n      const result = struct(obj[key]);\n      if (result.isErr()) {\n        return Err(result.unwrapErr());\n      }\n    }\n    return Ok(obj);\n  };\n}\n","import { None, Option, Some } from \"../../option\";\nimport { Ok } from \"../../result\";\nimport { isNil } from \"../../type-guards\";\nimport { Struct } from \"../types\";\n\nexport const optional =\n  <T>(struct: Struct<T>): Struct<Option<T>> =>\n  (input) => {\n    if (isNil(input)) return Ok(None);\n    return struct(input).andThen((value) => Ok(Some(value)));\n  };\n","import { Err, Ok } from \"../../result\";\nimport { isPlainObject } from \"../../type-guards\";\nimport { Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const record =\n  <K extends string, T>(\n    key: Struct<K>,\n    value: Struct<T>,\n  ): Struct<Record<K, T>> =>\n  (input) => {\n    if (!isPlainObject(input)) return Err(createError());\n    const obj = Object.create(null);\n    for (const [k, v] of Object.entries(input)) {\n      const kr = key(k);\n      if (kr.isErr()) {\n        const err = kr.unwrapErr();\n        err.path.unshift(k);\n        return Err(err);\n      }\n      const vr = value(v);\n      if (vr.isErr()) {\n        const err = vr.unwrapErr();\n        err.path.unshift(k);\n        return Err(err);\n      }\n      obj[kr.unwrap()] = vr.unwrap();\n    }\n    return Ok(obj);\n  };\n","import { Err, Ok } from \"../../result\";\nimport { isString } from \"../../type-guards\";\nimport { Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const string =\n  (opts?: { coerce?: boolean; trim?: boolean }): Struct<string> =>\n  (input) => {\n    if (opts?.coerce) {\n      input = String(input);\n    }\n    return isString(input)\n      ? Ok(opts?.trim ? input.trim() : input)\n      : Err(createError());\n  };\n","import { Err, Ok } from \"../../result\";\nimport { isArray } from \"../../type-guards\";\nimport { Infer, InferTuple, Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const tuple = <A extends Struct, B extends Struct[]>(\n  structs: [A, ...B],\n): Struct<[Infer<A>, ...InferTuple<B>]> => {\n  const entries = [...structs.entries()];\n  return (input) => {\n    if (!isArray(input)) return Err(createError());\n    const arr = new Array(structs.length);\n    for (const [i, struct] of entries) {\n      const result = struct(input[i]);\n      if (result.isErr()) {\n        const err = result.unwrapErr();\n        err.path.unshift(i.toString());\n        return Err(err);\n      }\n      arr[i] = result.unwrap();\n    }\n    return Ok(arr as any);\n  };\n};\n","import { Err, Ok } from \"../../result\";\nimport { Infer, InferTuple, Struct } from \"../types\";\nimport { createError } from \"../util\";\n\nexport const union =\n  <A extends Struct, B extends Struct[]>(\n    structs: [A, ...B],\n  ): Struct<Infer<A> | InferTuple<B>[number]> =>\n  (input) => {\n    for (const struct of structs) {\n      const result = struct(input);\n      if (result.isOk()) return Ok(result.unwrap() as any);\n    }\n    return Err(createError());\n  };\n","import { Ok } from \"../../result\";\nimport { Struct } from \"../types\";\n\nexport const unknown: Struct<unknown> = (input) => Ok(input);\n"],"names":["isInstanceOf","constructor","value","isString","isNumber","isBoolean","isBigInt","isSymbol","isUndefined","isFunction","isNull","isNil","PRIMITIVES","isPrimitive","f","isDate","isArray","isPlainObject","proto","isIterable","obj","isPromise","isPresent","isRegExp","isSet","isMap","isPositive","num","isNegative","isInteger","isFloat","isEven","isOdd","isPrime","sq","i","raise","err","assert","condition","msg","identity","arg","Err","Some","op","def","_","None","res","Ok","ok","toResult","toAsyncResult","isResult","NONE","optb","v","predicate","toOption","isOption","getIndex","arr","at","index","insert","item","copy","move","from","to","remove","shuffle","j","temp","swap","a","b","range","step","group","key","groupBy","List","init","values","U.at","other","n","U.group","U.groupBy","U.insert","U.move","U.remove","U.shuffle","p","U.swap","createError","array","struct","input","result","boolean","opts","chain","fns","prev","fn","date","defaulted","defaultValue","enums","en","intersection","structs","list","s","literal","constant","map","number","object","shape","entries","k","kr","vr"],"mappings":"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"}